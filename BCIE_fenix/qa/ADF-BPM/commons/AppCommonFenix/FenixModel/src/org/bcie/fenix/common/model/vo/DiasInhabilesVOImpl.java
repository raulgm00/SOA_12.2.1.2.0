package org.bcie.fenix.common.model.vo;

import java.text.ParseException;
import java.text.SimpleDateFormat;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.List;

import oracle.adf.share.logging.ADFLogger;

import oracle.jbo.Row;
import oracle.jbo.ViewCriteria;
import oracle.jbo.server.ViewObjectImpl;

import org.bcie.fenix.common.model.vo.common.DiasInhabilesVO;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Thu Jun 15 11:37:19 CDT 2017
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class DiasInhabilesVOImpl extends ViewObjectImpl implements DiasInhabilesVO {

    private static ADFLogger logger = null;

    /**
     * This is the default constructor (do not remove).
     */
    public DiasInhabilesVOImpl() {
        if (logger == null) {
            logger = ADFLogger.createADFLogger(this.getClass());
        }
    }
    
    public void probarFechaCalculoDefinitivoActual() {
        logger.log(ADFLogger.WARNING, "Entrando en probarFechaCalculoDefinitivoActual.");
        long startTime = System.currentTimeMillis();
        SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
        Date fechaPrepago;
        try {
            Calendar calendar = new GregorianCalendar(2016, 11, 13, 0, 0, 0);
            fechaPrepago = new Date(calendar.getTime().getTime());

            Calendar fechaRangoInicial = new GregorianCalendar(2016, 11, 13, 0, 0, 0);
            fechaRangoInicial.add(Calendar.MONTH, -2);

            String monenda = "USD";
            int dias = 10;

            fechaCalculoDefinitivo(fechaPrepago, dias, monenda, fechaRangoInicial.getTime(), fechaPrepago);

        } catch (Exception e) {
            logger.log(ADFLogger.WARNING, "error de conversion.", e);
        }

        long endTime = System.currentTimeMillis();
        logger.warning(">>> Tiempo de ejecucion del metodo probarFechaCalculoDefinitivoActual:  " +
                       (endTime - startTime) / 1000 + " segundos");
    }

    private Calendar fechaCalculoDefinitivo(Date fechaInicial, Integer dias, String moneda, Date fechaRangoInicial,
                                            Date fechaRangoFinal) {
        logger.log(ADFLogger.WARNING, "Entrando en fechaCalculoDefinitivo.");
        logger.log(ADFLogger.WARNING, "fechaInicial: " + fechaInicial);
        logger.log(ADFLogger.WARNING, "dias: " + dias);
        logger.log(ADFLogger.WARNING, "moneda: " + moneda);
        logger.log(ADFLogger.WARNING, "fechaRangoInicial: " + fechaRangoInicial);
        logger.log(ADFLogger.WARNING, "fechaRangoFinal: " + fechaRangoFinal);

        String diaInhabil = null;
        String diaInicio = null;
        Date fechaInicio = null;
        Integer diasHabiles = 0;
        Integer cantidadDiasInhabiles = 0;
        Boolean fechaBusqueda = Boolean.FALSE;
        List<Date> diasInhabiles = new ArrayList<Date>();
        diasInhabiles = (ArrayList) obtenerDiasInhabilesMonedaRango(moneda, fechaRangoInicial, fechaRangoFinal);
        logger.warning("Lista dias: " + diasInhabiles.size());

        Calendar fechaInicialCal = Calendar.getInstance();
        fechaInicialCal.setTime(fechaInicial);

        if (diasInhabiles != null) {

            while (diasHabiles < dias || fechaBusqueda) {
                fechaInicio = fechaInicialCal.getTime();
                for (Date fechaInhabil : diasInhabiles) {
                    logger.warning(" fechaInicio" + fechaInicio + "| | |fechaInhabil: " + fechaInhabil);
                    if (compararIgualdadFecha(fechaInhabil, fechaInicio)) {
                        logger.warning("la fecha inicial : " + fechaInicio + " es igual a fecha inhabil : " + fechaInhabil);
                        fechaBusqueda = Boolean.TRUE;
                        diasHabiles--;
                        cantidadDiasInhabiles++;
                    } else {

                        fechaBusqueda = Boolean.FALSE;
                    }
                }

                if ((!fechaBusqueda) && (diasHabiles < dias)) {
                    diasHabiles++;
                }

                fechaInicialCal.add(Calendar.DAY_OF_YEAR, -1);
            }
        }

        logger.warning("Fecha maxima para solicitar el prepago: " + fechaInicialCal.getTime());
        logger.warning("dias habiles: " + diasHabiles);
        logger.warning("dias inhabiles encontrados: " + cantidadDiasInhabiles);


        logger.exiting(this.getClass().getName(), "fechaCalculoDefinitivo", fechaInicialCal);
        return (fechaInicialCal);
    }

    private boolean compararIgualdadFecha(Date fechaA, Date fechaB) {
        boolean fechasIguales = Boolean.FALSE;

        Calendar fechaInicial = new GregorianCalendar();
        fechaInicial.setTime(fechaA);

        Calendar fechaFinal = new GregorianCalendar();
        fechaFinal.setTime(fechaB);

        if (null != fechaA && null != fechaB) {
            //int anioA = 2000 + fechaInicial.get(Calendar.YEAR);
            int anioA = fechaInicial.get(Calendar.YEAR);
            int anioB = fechaFinal.get(Calendar.YEAR);

            int mesA = fechaInicial.get(Calendar.MONTH);
            int mesB = fechaFinal.get(Calendar.MONTH);

            int diaA = fechaInicial.get(Calendar.DAY_OF_MONTH);
            int diaB = fechaFinal.get(Calendar.DAY_OF_MONTH);

            //logger.log(ADFLogger.WARNING, "Compraracion. " + anioA + "/" + mesA + "/" + diaA + " - " + anioB + "/" + mesB + "/" + diaB);
            if (anioA == anioB && mesA == mesB && diaA == diaB) {
                fechasIguales = Boolean.TRUE;
            }
        } else {
            logger.log(ADFLogger.WARNING, "Error, no se puede comparar fechas nulas.");
        }

        return fechasIguales;
    }

    public List obtenerDiasInhabilesMonedaRango(String descripcionMoneda, Date fechaRangoInicial,
                                                Date fechaRangoFinal) {
        logger.warning("Dentro obtenerDiasInhabilesMonedaRango");
        SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
        String fechaString = null;
        Date fecha = null;
        List<Date> listaDiasInhabiles = new ArrayList<Date>();
        filtrarPorCodigoMonedaRango(descripcionMoneda, fechaRangoInicial, fechaRangoFinal);

        this.setRangeSize(-1);

        for (Row row : this.getAllRowsInRange()) {
            Date dia = (Date) row.getAttribute("Dia");
            try {
                fechaString = formatter.format(dia);
                //logger.warning("fechaString: " + fechaString);
                fecha = formatter.parse(fechaString);
                //logger.warning("fecha: " + fecha.toString());
                listaDiasInhabiles.add(fecha);
            } catch (ParseException e) {
                logger.severe("Error obtenerDiasInhabilesMoneda : ", e);
            }
        }

        logger.warning("Tamaño de la lista de dias inhabiles : " + listaDiasInhabiles.size());
        return (listaDiasInhabiles);
    }

    private void filtrarPorCodigoMonedaRango(String codigoMoneda, Date fechaRangoInicial, Date fechaRangoFinal) {
        logger.warning("Dentro filtrarPorCodigoMonedaRango.");
        logger.warning("codigoMoneda: " + codigoMoneda);
        logger.warning("fechaRangoInicial: " + fechaRangoInicial);
        logger.warning("fechaRangoFinal: " + fechaRangoFinal);

        try {
            Calendar fechaInicalCal = Calendar.getInstance();
            fechaInicalCal.setTime(fechaRangoInicial);

            Calendar fechaFinalCal = Calendar.getInstance();
            fechaFinalCal.setTime(fechaRangoFinal);

            logger.warning("setpAnioInicial: " + fechaInicalCal.get(Calendar.YEAR) + " setpAnioFinal: " +
                           fechaFinalCal.get(Calendar.YEAR));

            setpAnioInicial(fechaInicalCal.get(Calendar.YEAR));
            setpAnioFinal(fechaFinalCal.get(Calendar.YEAR));
            setpCodigoMoneda(codigoMoneda);
            executeQuery();
            logger.warning("Cantidad de row obtenidos : " + this.getEstimatedRowCount());
        } catch (Exception ex) {
            logger.severe("Error en filtrarPorCodigoMoneda : ", ex);
        }
        logger.warning("Fuera filtrarPorCodigoMoneda, cantidad de registros obtenidos : " +
                       this.getEstimatedRowCount());
    }

    /**
     * Returns the bind variable value for pCodigoMoneda.
     * @return bind variable value for pCodigoMoneda
     */
    public String getpCodigoMoneda() {
        return (String) getNamedWhereClauseParam("pCodigoMoneda");
    }

    /**
     * Sets <code>value</code> for bind variable pCodigoMoneda.
     * @param value value to bind as pCodigoMoneda
     */
    public void setpCodigoMoneda(String value) {
        setNamedWhereClauseParam("pCodigoMoneda", value);
    }

    /**
     * Returns the bind variable value for pAnioInicial.
     * @return bind variable value for pAnioInicial
     */
    public Integer getpAnioInicial() {
        return (Integer) getNamedWhereClauseParam("pAnioInicial");
    }

    /**
     * Sets <code>value</code> for bind variable pAnioInicial.
     * @param value value to bind as pAnioInicial
     */
    public void setpAnioInicial(Integer value) {
        setNamedWhereClauseParam("pAnioInicial", value);
    }

    /**
     * Returns the bind variable value for pAnioFinal.
     * @return bind variable value for pAnioFinal
     */
    public Integer getpAnioFinal() {
        return (Integer) getNamedWhereClauseParam("pAnioFinal");
    }

    /**
     * Sets <code>value</code> for bind variable pAnioFinal.
     * @param value value to bind as pAnioFinal
     */
    public void setpAnioFinal(Integer value) {
        setNamedWhereClauseParam("pAnioFinal", value);
    }


}

